#!/usr/bin/env node
/**
 * pm2.js - Unified PM2 launcher for DEXBot2
 *
 * One-command startup for DEXBot2 with PM2 process management.
 * Handles all setup required before starting bot processes:
 *
 * 1. BitShares Connection
 *    - Waits for BitShares network connection
 *    - Suppresses debug output to keep terminal clean
 *
 * 2. PM2 Installation Check
 *    - Detects local and global PM2 installations
 *    - Prompts to install PM2 if missing
 *
 * 3. Ecosystem Configuration Generation
 *    - Reads bot definitions from profiles/bots.json
 *    - Generates profiles/ecosystem.config.js with absolute paths
 *    - Filters only active bots (active !== false)
 *    - If bot-name provided, filters to only that bot
 *
 * 4. Master Password Authentication
 *    - Prompts user interactively for master password
 *    - Suppresses BitShares logs during prompt
 *    - Password kept in RAM only (never saved to disk)
 *
 * 5. PM2 Startup
 *    - Passes master password via MASTER_PASSWORD environment variable
 *    - Each bot process receives password from env var
 *    - Spawns configured bots as PM2 managed processes
 *
 * Usage:
 *   node pm2.js              - Full setup and start all active bots
 *   node pm2.js <bot-name>   - Start only the specified bot via PM2
 *   node dexbot.js pm2       - Same as 'node pm2.js' via CLI
 *   npm run pm2:unlock-start - Same as 'node pm2.js' via npm script
 *
 * Security:
 *   - Master password never written to disk
 *   - No .env files created
 *   - Password only in process memory
 *   - Cleared when process exits
 *
 * Output:
 *   - Clean startup messages (BitShares connection status)
 *   - Ecosystem generation confirmation
 *   - Active bot count
 *   - PM2 management commands reference
 */

const fs = require('fs');
const path = require('path');
const { spawn, exec } = require('child_process');
const { promisify } = require('util');
const { parseJsonWithComments } = require('./modules/account_bots');

const execAsync = promisify(exec);

const ROOT = __dirname;
const PROFILES_DIR = path.join(ROOT, 'profiles');
const BOTS_JSON = path.join(PROFILES_DIR, 'bots.json');
const ECOSYSTEM_FILE = path.join(PROFILES_DIR, 'ecosystem.config.js');
const LOGS_DIR = path.join(PROFILES_DIR, 'logs');

// Generate ecosystem.config.js from bots.json
function generateEcosystemConfig(botNameFilter = null) {
    if (!fs.existsSync(BOTS_JSON)) {
        console.error('profiles/bots.json not found. Run: npm run bootstrap:profiles');
        process.exit(1);
    }

    // Ensure logs directory exists
    if (!fs.existsSync(LOGS_DIR)) {
        fs.mkdirSync(LOGS_DIR, { recursive: true });
    }

    const content = fs.readFileSync(BOTS_JSON, 'utf8');
    const config = parseJsonWithComments(content);
    let bots = (config.bots || []).filter(b => b.active !== false);

    // Filter to specific bot if name provided
    if (botNameFilter) {
        bots = bots.filter(b => b.name === botNameFilter);
        if (bots.length === 0) {
            console.error(`Bot '${botNameFilter}' not found or not active in profiles/bots.json`);
            process.exit(1);
        }
    } else if (bots.length === 0) {
        console.error('No active bots found in profiles/bots.json');
        process.exit(1);
    }

    const apps = bots.map((bot, index) => {
        const botName = bot.name || `bot-${index}`;
        return {
            name: botName,
            script: path.join(ROOT, 'bot.js'),
            args: botName,
            cwd: ROOT,
            max_memory_restart: '250M',
            watch: false,
            autorestart: true,
            error_file: path.join(LOGS_DIR, `${botName}-error.log`),
            out_file: path.join(LOGS_DIR, `${botName}.log`),
            log_date_format: 'YY-MM-DD HH:mm:ss.SSS',
            merge_logs: false,
            combine_logs: true,
            max_restarts: 13,
            min_uptime: 86400000,
            restart_delay: 3000
        };
    });

    const ecosystemContent = `// Auto-generated by pm2.js - DO NOT EDIT
// Regenerate with: node pm2.js or node dexbot.js pm2
module.exports = { apps: ${JSON.stringify(apps, null, 2)} };
`;

    fs.writeFileSync(ECOSYSTEM_FILE, ecosystemContent);
    console.log(`Ecosystem configuration generated`);
    return apps;
}

// Authenticate master password (assumes BitShares already connected)
async function authenticateWithoutWait() {
    const chainKeys = require('./modules/chain_keys');

    try {
        const password = await chainKeys.authenticate();
        console.log('Master password authenticated');
        return password;
    } catch (err) {
        if (err.message && err.message.includes('No master password set')) {
            console.error('No master password set. Run: node dexbot.js keys');
            process.exit(1);
        }
        throw err;
    }
}

// Start PM2 with environment
function startPM2(masterPassword) {
    return new Promise((resolve, reject) => {
        const env = { ...process.env, MASTER_PASSWORD: masterPassword };
        
        // Use 'pm2 start' to handle both cases:
        // 1. First run (processes don't exist yet) - creates new processes
        // 2. Subsequent runs (processes exist) - restarts existing processes gracefully
        // This prevents duplicate processes while supporting both fresh start and restart scenarios
        const pm2 = spawn('pm2', ['start', ECOSYSTEM_FILE], {
            cwd: ROOT,
            env,
            stdio: 'inherit',
            detached: false
        });

        pm2.on('close', code => {
            if (code === 0) {
                // Ensure we disconnect from PM2's file descriptors
                setImmediate(resolve);
            } else {
                reject(new Error(`PM2 exited with code ${code}`));
            }
        });

        pm2.on('error', reject);
    });
}

// Check if PM2 is installed (local or global)
function checkPM2Installed() {
    try {
        require.resolve('pm2');
        return true;
    } catch (e) {
        // Check if pm2 is available in PATH
        const { execSync } = require('child_process');
        try {
            execSync('pm2 --version', { stdio: 'ignore' });
            return true;
        } catch (err) {
            return false;
        }
    }
}

// Prompt to install PM2
async function installPM2() {
    const readline = require('readline');
    const { spawn } = require('child_process');

    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    return new Promise((resolve, reject) => {
        rl.question('PM2 is not installed. Install now? (Y/n): ', (answer) => {
            rl.close();

            if (answer.toLowerCase() === 'n') {
                console.log('PM2 installation cancelled. Run: npm install -g pm2');
                process.exit(1);
            }

            console.log('Installing PM2...');
            const npm = spawn('npm', ['install', '-g', 'pm2'], { stdio: 'inherit' });

            npm.on('close', (code) => {
                if (code === 0) {
                    console.log('PM2 installed successfully!');
                    resolve();
                } else {
                    reject(new Error('PM2 installation failed'));
                }
            });

            npm.on('error', reject);
        });
    });
}

// Execute PM2 command via shell
async function execPM2Command(action, target) {
    const command = `pm2 ${action} ${target}`;
    console.log(`Executing: ${command}`);

    try {
        const { stdout, stderr } = await execAsync(command);
        if (stdout) console.log(stdout);
        if (stderr) console.error(stderr);
        return { success: true, stdout, stderr };
    } catch (error) {
        console.error(`PM2 command failed: ${error.message}`);
        return { success: false, error };
    }
}

// Stop PM2 processes (only dexbot ones)
async function stopPM2Processes(target) {
    console.log(`Stopping PM2 processes: ${target}`);

    if (target === 'all') {
        // Stop all dexbot processes via ecosystem config
        const result = await execPM2Command('stop', ECOSYSTEM_FILE);
        if (result.success) {
            console.log('All dexbot PM2 processes stopped.');
        }
    } else {
        // Stop specific bot by name
        const result = await execPM2Command('stop', target);
        if (result.success) {
            console.log(`PM2 process '${target}' stopped.`);
        } else if (result.error && result.error.message && result.error.message.includes('not found')) {
            console.log(`Bot '${target}' not found in PM2.`);
        }
    }
}

// Delete PM2 processes (only dexbot ones)
async function deletePM2Processes(target) {
    console.log(`Deleting PM2 processes: ${target}`);

    if (target === 'all') {
        // Delete all dexbot processes via ecosystem config
        const result = await execPM2Command('delete', ECOSYSTEM_FILE);
        if (result.success) {
            console.log('All dexbot PM2 processes deleted.');
        }
    } else {
        // Delete specific bot by name
        const result = await execPM2Command('delete', target);
        if (result.success) {
            console.log(`PM2 process '${target}' deleted.`);
        } else if (result.error && result.error.message && result.error.message.includes('not found')) {
            console.log(`Bot '${target}' not found in PM2.`);
        }
    }

    console.log('Bot configs remain in profiles/bots.json.');
    console.log('Run "node dexbot.js bots" to manage bot configurations.');
}

// Show help text
function showPM2Help() {
    console.log(`
Usage: node pm2.js <command> [target]

Commands:
  unlock-start              Unlock keystore and start all bots with PM2 (default)
  stop <bot-name|all>       Stop PM2 process(es) - only dexbot processes
  delete <bot-name|all>     Delete PM2 process(es) - only dexbot processes
  help                      Show this help message

Examples:
  node pm2.js                    # Start all bots (unlock + start)
  node pm2.js stop all           # Stop all dexbot processes
  node pm2.js stop XRP-BTS       # Stop specific bot
  node pm2.js delete all         # Delete all dexbot processes from PM2
  node pm2.js delete XRP-BTS     # Delete specific bot from PM2
  node pm2.js help               # Show help
    `);
}

// Main
async function main(botNameFilter = null) {
    console.log('='.repeat(50));
    console.log('DEXBot2 PM2 Launcher');
    if (botNameFilter) {
        console.log(`Starting bot: ${botNameFilter}`);
    }
    console.log('='.repeat(50));
    console.log();

    // Step 0: Wait for BitShares connection (suppress BitShares client logs)
    const { waitForConnected } = require('./modules/bitshares_client');
    console.log('Connecting to BitShares...');

    // Suppress BitShares console output during connection
    const originalLog = console.log;
    console.log = (...args) => {
        // Only suppress BitShares-specific messages
        const msg = args.join(' ');
        if (!msg.includes('bitshares_client') && !msg.includes('modules/')) {
            originalLog(...args);
        }
    };

    await waitForConnected(30000);

    // Restore console output
    console.log = originalLog;
    console.log('Connected to BitShares');
    console.log();

    // Step 1: Check PM2
    if (!checkPM2Installed()) {
        console.error('PM2 is not installed');
        await installPM2();
    }

    // Step 2: Generate ecosystem config
    console.log('Generating ecosystem configuration...');
    const apps = generateEcosystemConfig(botNameFilter);
    console.log(`Number active bots: ${apps.length}`);
    console.log();

    // Step 3: Authenticate
    console.log('Authenticating master password...');
    const masterPassword = await authenticateWithoutWait();
    console.log();

    // Step 3: Start PM2
    console.log('Starting PM2...');
    await startPM2(masterPassword);

    console.log();
    console.log('='.repeat(50));
    console.log('DEXBot2 started successfully!');
    console.log('='.repeat(50));
    console.log();
}

// Run if called directly
if (require.main === module) {
    // Parse command line arguments
    const args = process.argv.slice(2);
    const command = args[0] || 'unlock-start';
    const target = args[1];

    (async () => {
        try {
            if (command === 'unlock-start') {
                // Full setup: unlock, generate config, authenticate, start PM2
                // Optional: filter to specific bot if provided
                await main(target || null);
                // Close stdin to prevent hanging
                if (process.stdin) process.stdin.destroy();
                process.exit(0);
            } else if (command === 'stop') {
                if (!target) {
                    console.error('Error: Target required. Specify bot name or "all".');
                    showPM2Help();
                    process.exit(1);
                }
                await stopPM2Processes(target);
                process.exit(0);
            } else if (command === 'delete') {
                if (!target) {
                    console.error('Error: Target required. Specify bot name or "all".');
                    showPM2Help();
                    process.exit(1);
                }
                await deletePM2Processes(target);
                process.exit(0);
            } else if (command === 'help') {
                showPM2Help();
                process.exit(0);
            } else {
                console.error(`Unknown command: ${command}`);
                showPM2Help();
                process.exit(1);
            }
        } catch (err) {
            console.error('Error:', err.message);
            process.exit(1);
        }
    })();
}

module.exports = { main, generateEcosystemConfig, authenticateWithoutWait };
